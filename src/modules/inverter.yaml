uart:
  - id: uart_inverter
    baud_rate: 2400
    tx_pin: ${inverter_tx_pin}
    rx_pin: ${inverter_rx_pin}
    debug:
#      direction: BOTH
#      dummy_receiver: false

modbus:
  - id: modbus_inverter
    uart_id: uart_inverter
    send_wait_time: 250ms

modbus_controller:
  - id: smg_inverter
    address: 0x05
    modbus_id: modbus_inverter
    setup_priority: -10
    offline_skip_updates: 100
    command_throttle: 1s
    update_interval: ${update_interval}

sensor:

# Testing Write Registers
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Write Register 5001"
    #id: battery_discharge_current
    address: 5001
    register_type: holding
    #value_type: U_WORD
    unit_of_measurement: "?"
    #device_class: current
    #state_class: measurement
    #accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Write Register 5039"
    #id: battery_discharge_current
    address: 5039
    register_type: holding
    #value_type: U_WORD
    unit_of_measurement: "?"
    #device_class: current
    #state_class: measurement
    #accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);  
  
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Write Register 5040"
    #id: battery_discharge_current
    address: 5040
    register_type: holding
    #value_type: U_WORD
    unit_of_measurement: "?"
    #device_class: current
    #state_class: measurement
    #accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);

  # Testing Write Registers
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Write Register 5041"
    #id: battery_discharge_current
    address: 5041
    register_type: holding
    #value_type: U_WORD
    unit_of_measurement: "?"
    #device_class: current
    #state_class: measurement
    #accuracy_decimals: 1
    lambda: |-
      return swapBytes(x); 

  ###################################
  # Read first group (44 registers) #
  #        4501 - 4530              #
  ###################################

  # 4501 -> text

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Grid Voltage"
    address: 4502
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      if (!id(grid_active).state) {
        return 0.0;
      } else {
        return swapBytes(x);
      }
    filters:
      - multiply: 0.1
      - offset: ${inverter_voltage_offset}
      - heartbeat: 10s
    on_raw_value:
      then:
        - lambda: !lambda |-
            if (!id(grid_active).state) {
              id(pzem_grid_voltage).publish_state(0.0);
              id(pzem_grid_current).publish_state(${pzem1_current_offset} * -1);
              id(pzem_grid_power).publish_state(0.0);
              id(pzem_grid_power_factor).publish_state(0.0);
            }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Grid Frequency"
    address: 4503
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "PV Voltage"
    id: pv_voltage
    address: 4504
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "PV Power"
    id: pv_power
    address: 4505
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      if (id(pv_voltage).state < 89) {
        return 0;
      } else {
        return swapBytes(x);
      }

  - platform: total_daily_energy
    power_id: pv_total
    name: "PV Daily Energy"
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing

  - platform: integration
    name: 'PV Total Energy'
    id: pv_total_energy
    sensor: pv_total
    time_unit: h
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    restore: true
    state_class: total_increasing
    device_class: energy

  - platform: template
    name: "PV Current"
    id: pv_current
    state_class: "measurement"
    device_class: current
    unit_of_measurement: "A"
    accuracy_decimals: 1
    icon: mdi:solar-power
    lambda: |-
      if (id(pv_voltage).state == 0) {
        return 0;
      } else {
        return id(pv_power).state / id(pv_voltage).state;
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Voltage"
    id: battery_voltage
    address: 4506
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery SoC"
    accuracy_decimals: 0
    unit_of_measurement: "%"
    device_class: battery
    address: 4507
    register_type: holding
    value_type: U_WORD
    state_class: measurement
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Charge Current"
    id: battery_charge_current
    address: 4508
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Discharge Current"
    id: battery_discharge_current
    address: 4509
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);

  - platform: template
    name: "Battery Current"
    id: battery_current
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_charge_current).state - id(battery_discharge_current).state;
    filters:
      - heartbeat: 10s

  - platform: template
    name: "Battery Power"
    id: battery_power
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_current).state * id(battery_voltage).state;

  - platform: template
    name: "Battery Discharge Power"
    id: battery_discharge_power
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_discharge_current).state * id(battery_voltage).state;

  - platform: template
    name: "Battery Charge Power"
    id: battery_charge_power
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    update_interval: ${update_interval}
    lambda: |-
      return id(battery_charge_current).state * id(battery_voltage).state;

  - platform: total_daily_energy
    power_id: battery_charge_power
    name: "Battery Charge Daily Energy"
    id: battery_charge_daily_energy
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing

  - platform: total_daily_energy
    power_id: battery_discharge_power
    name: "Battery Discharge Daily Energy"
    id: battery_discharge_daily_energy
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Voltage"
    id: load_voltage
    address: 4510
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Frequency"
    address: 4511
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Apparent Power"
    id: load_apparent_power
    address: 4512
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "VA"
    device_class: apparent_power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Active Power"
    id: load_active_power
    address: 4513
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: total_daily_energy
    power_id: load_active_power
    name: "Load Daily Active Energy"
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing

  - platform: template
    name: "Load Current"
    id: load_current
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 3
    update_interval: ${update_interval}
    lambda: |-
      if (id(load_voltage).state == 0) {
        return 0;
      } else {
        return id(load_apparent_power).state / id(load_voltage).state;
      }

  - platform: template
    name: "Load Power Factor"
    id: load_power_factor
    device_class: power_factor
    state_class: measurement
    accuracy_decimals: 2
    update_interval: ${update_interval}
    lambda: |-
      if (id(load_apparent_power).state == 0) {
        return 0;
      } else {
        return id(load_active_power).state / id(load_apparent_power).state;
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Percent"
    address: 4514
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: power_factor
    state_class: measurement
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Percent 2"
    address: 4515
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: power_factor
    state_class: measurement
    lambda: |-
      return swapBytes(x);

  # 4516 -> binary

  - platform: modbus_controller 
    modbus_controller_id: smg_inverter
    id: exit_the_dual_output_voltage_point
    #name: "Exit The Dual Output Voltage Point"
    internal: true
    entity_category: diagnostic
    address: 4517
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1 

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Main CPU Version"
    entity_category: diagnostic
    address: 4518
    register_type: holding
    unit_of_measurement: ""
    value_type: U_WORD
    lambda: |-
      return swapBytes(x);
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # 4519 -> binary
  # 4520 -> text

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Load Power VA"
    entity_category: diagnostic
    address: 4521
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "VA"
    device_class: apparent_power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Load Power"
    entity_category: diagnostic
    address: 4522
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Grid Voltage"
    entity_category: diagnostic
    address: 4523
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Grid Current"
    entity_category: diagnostic
    address: 4524
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Battery Voltage"
    entity_category: diagnostic
    address: 4525
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Load Voltage"
    entity_category: diagnostic
    address: 4526
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Load Frequency"
    entity_category: diagnostic
    address: 4527
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Nominal Load Current"
    entity_category: diagnostic
    address: 4528
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      return swapBytes(x);

  # 4529 -> text
  # 4530 -> text

  #####################################
  ##        Reserved  (4  registers)  #
  #         4531 - 4534               #
  #####################################
 
  # 4531 -> Reserved
  # 4532 -> Reserved
  # 4533 -> Reserved
  # 4534 -> Reserved
 
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Reserved_4531"
    entity_category: diagnostic
    address: 4531
    register_type: holding
    value_type: U_WORD
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Reserved_4532"
    entity_category: diagnostic
    address: 4532
    register_type: holding
    value_type: U_WORD
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Reserved_4533"
    entity_category: diagnostic
    address: 4533
    register_type: holding
    value_type: U_WORD
    internal: true
    lambda: |-
      return swapBytes(x);

### This register is different from the previous 3
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Reserved_4534"
    entity_category: diagnostic
    address: 4534
    register_type: holding
    value_type: U_WORD
    internal: true
    lambda: |-
      return swapBytes(x);

  #####################################
  ##    END Reserved  (4  registers)  #
  #         4531 - 4534               #
  #####################################

  # 4535 -> binary
  # 4536 -> text
  # 4537 -> text
  # 4538 -> text
  # 4539 -> text

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Target Output Frequency"
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4540
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Hz"
    lambda: |-
      uint16_t value = swapBytes(x);
      updateUnknownSelect(value, id(output_frequency_select));
      switch (value) {
        case 0: return std::uint16_t(50);
        case 1: return std::uint16_t(60);
        default: return x;
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: maximum_total_charging_current
    #name: "Maximum Total Charging Current"
    internal: true
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4541
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: output_voltage
    #name: "Output Voltage"
    internal: true
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4542
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: maximum_utility_charging_current
    #name: "Maximum Utility Charging Current"
    internal: true
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4543
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "A"
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: back_to_utility_source_voltage
    #name: "Back To Utility Source Voltage"
    internal: true
    filters:
      - multiply: 0.1
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4544
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: back_to_battery_source_voltage
    #name: "Back To Battery Source Voltage"
    internal: true
    filters:
      - multiply: 0.1
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4545
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      return swapBytes(x);

  # ####################################
  # # Read second group (16 registers) #
  # ####################################

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Bulk Charging Voltage"
    id: bulk_charging_voltage
    filters:
      - multiply: 0.1
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4546
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Floating Charging Voltage"
    id: floating_charging_voltage
    filters:
      - multiply: 0.1
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4547
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Low CutOff Voltage"
    id: low_cutoff_voltage
    filters:
      - multiply: 0.1
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4548
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Battery Equalization Voltage"
    id: battery_equalization_voltage
    filters:
      - multiply: 0.1
    accuracy_decimals: 1
    entity_category: diagnostic
    address: 4549
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Battery Equalized Time"
    id: battery_equalized_time
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4550
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "minutes"
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Battery Equalized Timeout"
    id: battery_equalized_timeout
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4551
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "minutes"
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Battery Equalization Interval"
    id: battery_equalization_interval
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4552
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "days"
    internal: true
    lambda: |-
      return swapBytes(x);

  # 4553 -> binary

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Status Register 01"
    id: status_register_01
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4553
    register_type: holding
    value_type: U_WORD
    lambda: |-
      return swapBytes(x);

  # 4554 -> binary
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Status Register 02"
    id: status_register_02
    accuracy_decimals: 0
    entity_category: diagnostic
    address: 4554
    register_type: holding
    value_type: U_WORD
    lambda: |-
      return swapBytes(x);

  # 4555 -> text
  
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "PV Charging Status Raw"
    id: pv_charging_status
    address: 4556
    entity_category: diagnostic
    register_type: holding
    value_type: U_WORD
    internal: true
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Internal Temperature"
    id: temperature_internal
    unit_of_measurement: "Â°C"
    device_class: temperature
    state_class: measurement
    address: 4557
    register_type: holding
    value_type: U_WORD
    lambda: |-
      return swapBytes(x);

#Testing - Incorrect Value
#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    name: "Grid-tie Power (Incorrect)"
#    id: pv_grid_on_power
#    address: 4558
#    register_type: holding
#    value_type: U_WORD
#    unit_of_measurement: "W"
#    device_class: power
#    entity_category: diagnostic
#    lambda: |-
#      return swapBytes(x);

 # 4559 -> binary

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "Grid-tie Current"
    id: grid_tie_current
    address: 4560
    entity_category: diagnostic
    register_type: holding
    value_type: U_WORD
    internal: true
    unit_of_measurement: "A"
    state_class: measurement
    lambda: |-
      return swapBytes(x) * 2;

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    #name: "LED Pattern Light"
    id: led_pattern_light_status
    address: 4561
    register_type: holding
    value_type: U_WORD
    internal: true
    lambda: |-
      return swapBytes(x);

 # 4562 -> binary

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "PV2 Voltage"
    id: pv2_voltage
    address: 4563
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return swapBytes(x);
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "PV2 Power"
    id: pv2_power
    address: 4564
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      if (id(pv2_voltage).state < 89) {
        return 0;
      } else {
        return swapBytes(x);
      }

  - platform: total_daily_energy
    power_id: pv2_power
    name: "PV2 Daily Energy"
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing

  - platform: integration
    name: 'PV2 Total Energy'
    sensor: pv2_power
    time_unit: h
    filters:
      - multiply: 0.001
    unit_of_measurement: "kWh"
    restore: true
    state_class: total_increasing
    device_class: energy

  - platform: template
    name: "PV2 Current"
    id: pv2_current
    state_class: "measurement"
    device_class: current
    unit_of_measurement: "A"
    accuracy_decimals: 1
    icon: mdi:solar-power
    lambda: |-
      if (id(pv2_voltage).state == 0) {
        return 0;
      } else {
        return id(pv2_power).state / id(pv2_voltage).state;
      }

  - platform: template
    name: "PV Total"
    id: pv_total
    state_class: "measurement"
    device_class: power
    unit_of_measurement: "W"
    accuracy_decimals: 1
    icon: mdi:solar-power
    lambda: |-
      return id(pv_power).state + id(pv2_power).state;

binary_sensor:

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: dual_output_status
    #name: "Dual Output"
    internal: true
    entity_category: diagnostic
    address: 4516
    register_type: holding
    #value_type: U_WORD
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: battery_equalization_status
    #name: "Battery Equalization"
    internal: true
    entity_category: diagnostic
    address: 4519
    register_type: holding
    #value_type: U_WORD
    lambda: |-
      return swapBytes(x);
    on_press:
      then:
        - switch.turn_on: battery_equalization
        # - select.set_index:
        #     id: record_fault
        #     index: 1
    on_release:
      then:
        - switch.turn_off: battery_equalization
        # - select.set_index:
        #     id: record_fault
        #     index: 0  

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: record_fault_status
    #name: "Record Fault Code"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x1
    on_press:
      then:
        - switch.turn_on: record_fault
        # - select.set_index:
        #     id: record_fault
        #     index: 1
    on_release:
      then:
        - switch.turn_off: record_fault
        # - select.set_index:
        #     id: record_fault
        #     index: 0

# Implemented by another register 4519 and 4562
#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    name: "Battery Equalization"
#    entity_category: diagnostic
#    address: 4535
#    register_type: holding
#    bitmask: 0x2

#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    name: "Equalization Activated Immediately"
#    entity_category: diagnostic
#    address: 4535
#    register_type: holding
#    bitmask: 0x4

#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    id: alarm_status
#    #name: "Alarm"
#    internal: true
#    entity_category: diagnostic
#    address: 4535
#    register_type: holding
#    bitmask: 0x100

 #Testing Registers
 # - platform: modbus_controller
 #  modbus_controller_id: smg_inverter
 #   id: register_4535_0x8
 #   name: "Register 4535 (0x8)"
    #internal: true
 #   entity_category: diagnostic
 #   address: 4535
 #   register_type: holding
 #   bitmask: 0x8

 #Testing Registers
 # - platform: modbus_controller
 #   modbus_controller_id: smg_inverter
 #   id: register_4535_0x10
 #   name: "Register 4535 (0x10)"
    #internal: true
 #   entity_category: diagnostic
 #   address: 4535
 #   register_type: holding
 #   bitmask: 0x10

 #Testing Registers
 # - platform: modbus_controller
 #   modbus_controller_id: smg_inverter
 #   id: register_4535_0x20
 #   name: "Register 4535 (0x20)"
    #internal: true
 #   entity_category: diagnostic
 #   address: 4535
 #   register_type: holding
 #   bitmask: 0x20

 #Testing Registers
 # - platform: modbus_controller
 #   modbus_controller_id: smg_inverter
 #   id: register_4535_0x40
 #   name: "Register 4535 (0x40)"
    #internal: true
 #   entity_category: diagnostic
 #   address: 4535
 #   register_type: holding
 #   bitmask: 0x40

 #Testing Registers
 # - platform: modbus_controller
 #   modbus_controller_id: smg_inverter
 #   id: register_4535_0x80
 #   name: "Register 4535 (0x80)"
    #internal: true
 #   entity_category: diagnostic
 #   address: 4535
 #   register_type: holding
 #   bitmask: 0x80

 #Testing Registers
 # - platform: modbus_controller
 #   modbus_controller_id: smg_inverter
 #   id: register_4535_0x200
 #   name: "Register 4535 (0x200)"
    #internal: true
 #   entity_category: diagnostic
 #   address: 4535
 #   register_type: holding
 #   bitmask: 0x200

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: backlight_status
    #name: "Backlight"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x400
    on_press:
      then:
        - switch.turn_on: backlight
        # - select.set_index:
        #     id: backlight
        #     index: 1
    on_release:
      then:
        - switch.turn_off: backlight
        # - select.set_index:
        #     id: backlight
        #     index: 0

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: overload_restart_status
    #name: "Restart On Overload"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x800
    on_press:
      then:
        - switch.turn_on: overload_restart
        # - select.set_index:
        #     id: overload_restart
        #     index: 1
    on_release:
      then:
        - switch.turn_off: overload_restart
        # - select.set_index:
        #     id: overload_restart
        #     index: 0

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: temperature_restart_status
    #name: "Restart On Overheat"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x1000
    on_press:
      then:
        - switch.turn_on: temperature_restart
    on_release:
      then:
        - switch.turn_off: temperature_restart

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: beep_source_status
    #name: "Beep On Primary Source Fail"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x2000
    on_press:
      then:
        - switch.turn_on: source_beep
    on_release:
      then:
        - switch.turn_off: source_beep

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: screen_return_status
    #name: "Return To Default Screen"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x4000
    on_press:
      then:
        - switch.turn_on: auto_return
    on_release:
      then:
        - switch.turn_off: auto_return

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: overload_bypass_status
    #name: "Overload Bypass"
    internal: true
    entity_category: diagnostic
    address: 4535
    register_type: holding
    bitmask: 0x8000
    on_press:
      then:
        - switch.turn_on: overload_bypass
    on_release:
      then:
        - switch.turn_off: overload_bypass

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Discharge"
    id: battery_discharge
    address: 4553
    register_type: holding
    bitmask: 0x100

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Battery Charge"
    id: battery_charge
    address: 4553
    register_type: holding
    bitmask: 0x200

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "PV Active"
    id: pv_active
    address: 4553
    register_type: holding
    bitmask: 0x10

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Grid Active"
    id: grid_active
    address: 4553
    register_type: holding
    bitmask: 0x2000

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Load Enabled"
    address: 4553
    register_type: holding
    bitmask: 0x4000

# # Diagnostics ...
    
#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 0"
#     id: R4553_b0
#     address: 4553
#     register_type: holding
#     bitmask: 0x1

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 1"
#     id: R4553_b1
#     address: 4553
#     register_type: holding
#     bitmask: 0x2

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 2"
#     id: R4553_b2
#     address: 4553
#     register_type: holding
#     bitmask: 0x4

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 3"
#     id: R4553_b3
#     address: 4553
#     register_type: holding
#     bitmask: 0x8

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 4"
#     id: R4553_b4
#     address: 4553
#     register_type: holding
#     bitmask: 0x10

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 5"
#     id: R4553_b5
#     address: 4553
#     register_type: holding
#     bitmask: 0x20

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 6"
#     id: R4553_b6
#     address: 4553
#     register_type: holding
#     bitmask: 0x40

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 7"
#     id: R4553_b7
#     address: 4553
#     register_type: holding
#     bitmask: 0x80

#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    name: "On Battery"
#    entity_category: diagnostic
#    address: 4554
#    register_type: holding
#    bitmask: 0x100

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 9"
#     id: R4553_b9
#     address: 4553
#     register_type: holding
#     bitmask: 0x200

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 10"
#     id: R4553_b10
#     address: 4553
#     register_type: holding
#     bitmask: 0x400

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 11"
#     id: R4553_b11
#     address: 4553
#     register_type: holding
#     bitmask: 0x800

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 12"
#     id: R4553_b12
#     address: 4553
#     register_type: holding
#     bitmask: 0x1000

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 13"
#     id: R4553_b13
#     address: 4553
#     register_type: holding
#     bitmask: 0x2000

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 14"
#     id: R4553_b14
#     address: 4553
#     register_type: holding
#     bitmask: 0x4000

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4553 / bit 15"
#     id: R4553_b15
#     address: 4553
#     register_type: holding
#     bitmask: 0x8000

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 0"
#     id: R4554_b0
#     address: 4554
#     register_type: holding
#     bitmask: 0x1

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 1"
#     id: R4554_b1
#     address: 4554
#     register_type: holding
#     bitmask: 0x2

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 2"
#     id: R4554_b2
#     address: 4554
#     register_type: holding
#     bitmask: 0x4

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 3"
#     id: R4554_b3
#     address: 4554
#     register_type: holding
#     bitmask: 0x8

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 4"
#     id: R4554_b4
#     address: 4554
#     register_type: holding
#     bitmask: 0x10

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 5"
#     id: R4554_b5
#     address: 4554
#     register_type: holding
#     bitmask: 0x20

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 6"
#     id: R4554_b6
#     address: 4554
#     register_type: holding
#     bitmask: 0x40

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 7"
#     id: R4554_b7
#     address: 4554
#     register_type: holding
#     bitmask: 0x80

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 8"
#     id: R4554_b8
#     address: 4554
#     register_type: holding
#     bitmask: 0x100

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 9"
#     id: R4554_b9
#     address: 4554
#     register_type: holding
#     bitmask: 0x200

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 10"
#     id: R4554_b10
#     address: 4554
#     register_type: holding
#     bitmask: 0x400

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 11"
#     id: R4554_b11
#     address: 4554
#     register_type: holding
#     bitmask: 0x800

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 12"
#     id: R4554_b12
#     address: 4554
#     register_type: holding
#     bitmask: 0x1000

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 13"
#     id: R4554_b13
#     address: 4554
#     register_type: holding
#     bitmask: 0x2000

#   - platform: modbus_controller
#     modbus_controller_id: smg_inverter
#     name: "R4554 / bit 14"
#     id: R4554_b14
#     address: 4554
#     register_type: holding
#     bitmask: 0x4000

#  - platform: modbus_controller
#    modbus_controller_id: smg_inverter
#    name: "Grid Active"
#    id: grid_active
#    entity_category: diagnostic
#    address: 4554
#    register_type: holding
#    bitmask: 0x8000

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: grid_tie_operation_status
    #name: "Grid-tie Operation Status"
    internal: true
    entity_category: diagnostic
    address: 4559
    register_type: holding
    lambda: |-
      return swapBytes(x);

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: battery_equalization_activated_immediately_status
    #name: "Battery Equalization Activated Immediately Status"
    internal: true
    entity_category: diagnostic
    address: 4562
    register_type: holding
    lambda: |-
      return swapBytes(x);
    on_press:
      then:
        - switch.turn_on: battery_equalization_activated_immediately
    on_release:
      then:
        - switch.turn_off: battery_equalization_activated_immediately

text_sensor:

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: inverter_mode
    name: "Inverter Mode"
    address: 4501
    entity_category: diagnostic
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      switch (sensorIndex) {
        case 0: return std::string("Mode 0 (?)");
        case 1: return std::string("Mode 1 (?)");
        case 2: return std::string("Standby Mode (Charging Battery)");
        case 3: return std::string("Battery Mode");
        case 11: return std::string("Standby Mode, Charging");
        case 4: return std::string("Line Mode (Bypass)");
        default: return std::string(x);
      }

#Testing not sure correct values
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: battery_configuration
    name: "Battery Configuration"
    entity_category: diagnostic
    address: 4520
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      switch (sensorIndex) {
        case 0: return std::string("Without Battery");
        case 1: return std::string("24V (4.2KW)");
        case 2: return std::string("48V (5KW)");
        default: return std::string(x);
      }

#Testing - might have incorrect fault codes
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Inverter Faults"
    id: inverter_faults
    address: 4529
    #register_count: 5
    entity_category: diagnostic
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t faults = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      std::string fault_list = "";
      if (faults == 0) return {"No Faults"};
      if (faults & (1 << 0)) fault_list += "Over Temperature, ";
      if (faults & (1 << 1)) fault_list += "Battery Voltage Low, ";
      if (faults & (1 << 2)) fault_list += "Battery Voltage High, ";
      if (faults & (1 << 3)) fault_list += "Overload, ";
      if (faults & (1 << 4)) fault_list += "Output Short Circuit, ";
      if (faults & (1 << 5)) fault_list += "PV Over Voltage, ";
      if (faults & (1 << 6)) fault_list += "AC Input Voltage High, ";
      if (faults & (1 << 7)) fault_list += "AC Input Voltage Low, ";
      // Remove the last comma and space
      if (!fault_list.empty()) {
        fault_list.pop_back();
        fault_list.pop_back();
      }
      return {fault_list};

#Testing - Need to add more Error Codes
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    name: "Alarm Codes"
    id: alarm_codes
    address: 4530
    #register_count: 5
    entity_category: diagnostic
    register_type: holding
    response_size: 5
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      std::string StrWrnErr = to_string(sensorIndex) + ": ";
      if (sensorIndex == 0) {StrWrnErr += "No Alarms";}
      if (sensorIndex && 32768) {StrWrnErr += "Battery Equalization";}
      return std::string(StrWrnErr);

#      if (alarms & (1 << 0)) alarm_list += "Fan Locked Fan Alarm, ";
#      if (alarms & (1 << 1)) alarm_list += "Over Temperature Warning, ";
#      if (alarms & (1 << 2)) alarm_list += "Battery Voltage Low, ";
#      if (alarms & (1 << 3)) alarm_list += "Over Load Overload Warning, ";
#      if (alarms & (1 << 4)) alarm_list += "Output Power Derating, ";
#      if (alarms & (1 << 5)) alarm_list += "PV Energy Weak, ";
#      if (alarms & (1 << 6)) alarm_list += "AC Voltage High Input, ";
#      if (alarms & (1 << 8)) alarm_list += "No Battery Alarm, ";

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: charger_source_priority_status
    #name: "Charger Source Priority"
    internal: true
    entity_category: diagnostic
    address: 4536
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      updateUnknownSelect(sensorIndex, id(charger_source_priority_select));
      switch (sensorIndex) {
        case 0: return std::string("Solar first (CSO)");
        case 1: return std::string("Solar and Utility (SNU)");
        case 2: return std::string("Solar Only (OSO)");
        default: return std::string(x);
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: output_source_priority_status
    #name: "Output Source Priority"
    internal: true
    entity_category: diagnostic
    address: 4537
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      updateUnknownSelect(sensorIndex, id(output_source_priority_select));
      switch (sensorIndex) {
        case 0: return std::string("Utility -> Solar / Battery (USB)");
        case 1: return std::string("Solar -> Solar / Utility -> Battery (SUB)");
        case 2: return std::string("Solar -> Solar / Battery (SBU)");
        case 3: return std::string("Solar -> Solar / Utility, Battery as backup (MKS)");
        default: return std::string(x);
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: ac_voltage_range_status
    #name: "AC Input Voltage Range"
    internal: true
    entity_category: diagnostic
    address: 4538
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      updateUnknownSelect(value, id(ac_input_voltage_range_select));
      switch (value) {
        case 0: return std::string("Appliances");
        case 1: return std::string("UPS");
        default: return std::string(x);
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: battery_type_status
    #name: "Battery Type"
    internal: true
    entity_category: diagnostic
    address: 4539
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t value = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      updateUnknownSelect(value, id(battery_type_select));
      switch (value) {
        case 0: return {"AGM"};
        case 1: return {"Flooded"};
        case 2: return {"User Defined"};
        case 3: return {"Litium (LIB)"};
        case 4: return {"Litium (LIC)"};
        case 5: return {"Litium (LIP)"};
        case 6: return {"Litium (LIL)"};    
       default: return {"Unknown"};
      }

  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: inverter_status
    name: "Inverter Status"
    address: 4555
    register_type: holding
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t sensorIndex = swapBytes(modbus_controller::word_from_hex_str(x, 0));
      switch (sensorIndex) {
        case 10: return std::string("Discharging (A)");
        case 11: return std::string("Charging (B)");
        case 12: return std::string("Idle (C)");
        case 13: return std::string("Fully charged (D)");
        default: return std::string(x);
      }

switch:

# Menu Setting #06
  - platform: modbus_controller
    id: overload_restart
    name: "Auto restart when overload occurs"
    entity_category: config
    address: 5005
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #07
  - platform: modbus_controller
    id: temperature_restart
    name: "Auto restart when over temperature"
    entity_category: config
    address: 5006
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #18
  - platform: modbus_controller
    modbus_controller_id: smg_inverter
    id: alarm_control
    name: "Alarm Control"
    entity_category: config
    address: 5002
    force_new_range: true
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #19
  - platform: modbus_controller
    id: auto_return
    name: "Auto return to default display screen"
    entity_category: config
    address: 5008
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}    

# Menu Setting #20
  - platform: modbus_controller
    id: backlight
    name: "Backlight Control"
    entity_category: config
    address: 5004
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #22
  - platform: modbus_controller
    id: source_beep
    name: "Beep On Primary Source Fail"
    entity_category: config
    address: 5007
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #23
  - platform: modbus_controller
    id: overload_bypass
    name: "Overload Bypass"
    entity_category: config
    address: 5009
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #25 
  - platform: modbus_controller
    id: record_fault
    name: "Record fault code"
    entity_category: config
    address: 5010
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #30
  - platform: modbus_controller
    id: battery_equalization
    name: "Battery Equalization"
    entity_category: config
    address: 5011
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #36
  - platform: modbus_controller
    id: battery_equalization_activated_immediately
    name: "Battery Equalization activated immediately"
    entity_category: config
    address: 5012
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}

# Menu Setting #00
  - platform: modbus_controller
    id: restore_factory_defaults
    name: "Restore Factory Defaults"
    entity_category: config
    address: 5016
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}    

# Menu Setting #37
  - platform: modbus_controller
    id: grid_tie_operation
    name: "GRID-tie operation"
    entity_category: config
    address: 5034
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}   
    lambda: return id(grid_tie_operation_status).state;

# Menu Setting #39 
  - platform: modbus_controller
    id: led_pattern_light
    name: "LED Pattern Light"
    entity_category: config
    address: 5036
    force_new_range: true
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates} 
    lambda: return id(led_pattern_light_status).state;   

  # Menu Setting #41
  - platform: modbus_controller
    id: dual_output
    name: "Dual Output"
    force_new_range: true
    entity_category: config
    address: 5037
    modbus_controller_id: smg_inverter
    register_type: holding
    bitmask: 1
    icon: "mdi:toggle-switch"
    skip_updates: ${select_skip_updates}
    lambda: return id(dual_output_status).state;

select:

# Menu Setting #00 -> switch

#Untested.
  - platform: modbus_controller
    name: "Power saving mode"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5003
    value_type: U_WORD
    optionsmap:
      "OFF": 0
      "ON": 1

# Added functionality to write the full unit serial number.
  - platform: modbus_controller
    name: "Reserve 1"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5013
    value_type: U_WORD
    optionsmap:
      "OFF": 0
      "ON": 1

  - platform: modbus_controller
    name: "Reserve 2"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5014
    value_type: U_WORD
    optionsmap:
      "OFF": 0
      "ON": 1

  - platform: modbus_controller
    name: "Reserve 3"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5015
    value_type: U_WORD
    optionsmap:
      "OFF": 0
      "ON": 1

# Menu Setting #01
  - platform: modbus_controller
    id: output_source_priority_select
    name: "Output Source Priority"
    optimistic: true
    force_new_range: true
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5018
    value_type: U_WORD
    optionsmap:
      "Utility -> Solar / Battery (USB)": 0
      "Solar -> Solar / Utility -> Battery (SUB)": 1
      "Solar -> Solar / Battery (SBU)": 2
      "Solar -> Solar / Utility, Battery as backup (MKS)": 3

# Menu Setting #02
  - platform: modbus_controller
    id: maximum_charging_current_select
    name: "Maximum Charging Current"
    optimistic: true
    force_new_range: true
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5022
    value_type: U_WORD
    optionsmap:
      "10 A": 10
      "20 A": 20
      "30 A": 30
      "40 A": 40
      "50 A": 50
      "60 A": 60
      "70 A": 70
      "80 A": 80
      "90 A": 90
      "100 A": 100
      "110 A": 110
      "120 A": 120
      "130 A": 130
      "140 A": 140
      "150 A": 150
      "160 A": 160

# Menu Setting #03
  - platform: modbus_controller
    id: ac_input_voltage_range_select
    name: "AC Input Voltage Range"
    optimistic: true
    force_new_range: true
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5019
    value_type: U_WORD
    optionsmap:
      "90 - 280 V (APL)": 0
      "170 - 280 V (UPS)": 1

# Menu Setting #05
  - platform: modbus_controller
    id: battery_type_select
    name: "Battery Type"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5020
    value_type: U_WORD
    optionsmap:
      "AGM": 0
      "Flooded": 1
      "User Defined": 2     
      "Litium (LIB)": 3
      "Litium (LIC)": 4
      "Litium (LIP)": 5
      "Litium (LIL)": 6

# Menu Setting #06 -> switch
# Menu Setting #07 -> switch

# Menu Setting #09
  - platform: modbus_controller
    id: output_frequency_select
    name: "Output frequency"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5021
    value_type: U_WORD
    optionsmap:
      "50hz": 0
      "60hz": 1

# Menu Setting #10
  - platform: modbus_controller
    id: output_voltage_select
    name: "Output voltage"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5023
    value_type: U_WORD
    optionsmap:
      "220 V": 220
      "230 V": 230
      "240 V": 240

# Menu Setting #11
  - platform: modbus_controller
    id: maximum_utility_charging_current_select
    name: "Maximum Utility Charging Current"
    optimistic: true
    force_new_range: true
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5024
    value_type: U_WORD
    optionsmap:
      "2 A": 2
      "10 A": 10
      "20 A": 20
      "30 A": 30
      "40 A": 40
      "50 A": 50
      "60 A": 60
      "70 A": 70
      "80 A": 80
      "90 A": 90
      "100 A": 100
      "110 A": 110
      "120 A": 120
      "130 A": 130
      "140 A": 140

# Menu Setting #12
  - platform: modbus_controller
    id: soc_back_to_utility_source_voltage_select
    name: "SOC Back To Utility Source Voltage"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5025
    value_type: U_WORD
    optionsmap:
      "42 V": 420
      "43 V": 430
      "44 V": 440
      "45 V": 450
      "46 V": 460
      "47 V": 470
      "48 V": 480
      "49 V": 490
      "50 V": 500
      "51 V": 510

# Menu Setting #13
  - platform: modbus_controller
    id: soc_back_to_battery_voltage_select
    name: "SOC Back To Battery Voltage"
    optimistic: true
    force_new_range: true
    register_count: 1
    skip_updates: ${select_skip_updates}
    entity_category: config
    address: 5026
    value_type: U_WORD
    optionsmap:
      "48 V": 480
      "49 V": 490
      "50 V": 500
      "51 V": 510
      "52 V": 520
      "53 V": 530
      "54 V": 540
      "55 V": 550
      "56 V": 560
      "57 V": 570
      "58 V": 580

# Menu Setting #16
  - platform: modbus_controller
    id: charger_source_priority_select
    name: "Charger Source Priority"
    optimistic: true
    skip_updates: ${select_skip_updates}
    force_new_range: true
    entity_category: config
    address: 5017
    value_type: U_WORD
    optionsmap:
      "Solar first (CSO)": 0
      "Solar and Utility (SNU)": 1
      "Solar Only (OSO)": 2

# Menu Setting #18 -> switch
# Menu Setting #19 -> switch
# Menu Setting #20 -> switch
# Menu Setting #22 -> switch
# Menu Setting #23 -> switch
# Menu Setting #25 -> switch
# Menu Setting #26 -> number
# Menu Setting #27 -> number
# Menu Setting #29 -> number
# Menu Setting #30 -> switch
# Menu Setting #31 -> number
# Menu Setting #33 -> number
# Menu Setting #34 -> number
# Menu Setting #35 -> number
# Menu Setting #36 -> switch
# Menu Setting #37 -> switch
# Menu Setting #38 -> number
# Menu Setting #39 -> switch
# Menu Setting #41 -> switch
# Menu Setting #42 -> number

# Menu Setting #43 (bms communication address)
# Menu Setting #44 (delayed grid connection)
# Menu Setting #45 (battery soc percentage disconnection voltage)

number:

# Menu Setting #26
  - platform: modbus_controller
    name: "Bulk Charging Voltage"
    id: bulk_charging_voltage_number
    modbus_controller_id: smg_inverter
    entity_category: config
    address: 5027
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 48.0
    max_value: 61.0
    step: 0.1
    unit_of_measurement: "V"
    mode: 'slider'
    force_new_range: true
    multiply: 10

# Menu Setting #27
  - platform: modbus_controller
    name: "Floating charging voltage"
    id: floating_charging_voltage_number
    modbus_controller_id: smg_inverter
    entity_category: config
    address: 5028
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 48.0
    max_value: 61.0
    step: 0.1
    unit_of_measurement: "V"
    mode: 'slider'
    force_new_range: true
    multiply: 10

# Menu Setting #29 -> number
  - platform: modbus_controller
    name: "Low DC cut-off voltage"
    id: low_dc_cut_off_voltage_number
    modbus_controller_id: smg_inverter
    entity_category: config
    address: 5029
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 40.0
    max_value: 48.0
    step: 0.1
    unit_of_measurement: "V"
    mode: 'slider'
    force_new_range: true
    multiply: 10 

# Menu Setting #31
  - platform: modbus_controller
    name: "Battery Equalization voltage"
    id: battery_equalization_voltage_number
    modbus_controller_id: smg_inverter
    entity_category: config
    address: 5030
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 48.0
    max_value: 61.0
    step: 0.1
    unit_of_measurement: "V"
    mode: 'slider'
    force_new_range: true
    multiply: 10

# Menu Setting #33
  - platform: modbus_controller
    name: "Battery Equalized time"
    id: battery_equalized_time_number
    modbus_controller_id: smg_inverter
    entity_category: config
    address: 5031
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 5
    max_value: 900
    step: 5
    unit_of_measurement: "minutes"
    mode: 'slider'
    force_new_range: true

# Menu Setting #34
  - platform: modbus_controller
    name: "Battery Equalized timeout"
    id: battery_equalized_timeout_number
    modbus_controller_id: smg_inverter
    address: 5032
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 5
    max_value: 900
    step: 5
    unit_of_measurement: "minutes"
    mode: 'slider'
    force_new_range: true

# Menu Setting #35
  - platform: modbus_controller
    name: "Battery Equalization interval"
    id: battery_equalization_interval_number
    modbus_controller_id: smg_inverter
    address: 5033
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 0
    max_value: 90
    step: 1
    unit_of_measurement: "days"
    mode: 'slider'
    force_new_range: true

# Menu Setting #38
  - platform: modbus_controller
    name: "GRID-tie current"
    id: grid_tie_current_number
    modbus_controller_id: smg_inverter
    address: 5035
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 2
    max_value: 30
    step: 2
    unit_of_measurement: "A"
    mode: 'slider'
    force_new_range: true
    multiply: 0.5
    lambda: |-
      return id(grid_tie_current).state;

# Menu Setting #42    
  - platform: modbus_controller
    name: "Exit The Dual Output Voltage Point"
    id: exit_the_dual_output_voltage_point_number
    modbus_controller_id: smg_inverter
    entity_category: config
    address: 5038
    register_type: holding
    skip_updates: ${select_skip_updates}
    value_type: U_WORD
    min_value: 40.0
    max_value: 52.0
    step: 0.1
    unit_of_measurement: "V"
    mode: 'slider'
    force_new_range: true
    multiply: 10
    lambda: |-
      return id(exit_the_dual_output_voltage_point).state;

button:
  - platform: template
    name: "PV Total Energy Reset"
    on_press:
      then:
        - sensor.integration.reset: pv_total_energy
